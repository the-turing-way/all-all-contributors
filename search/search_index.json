{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"all-all contributors","text":""},{"location":"#all-all-contributors_1","title":"All All Contributors","text":"<p>All Contributors at the level of a GitHub Org</p> <p></p> <p></p> <p>This project is being developed as a part of the 2025 SSI Collaboration Workshop Hack Day.</p>"},{"location":"#introduction","title":"Introduction","text":"<p>Many communities that host their work on GitHub use the All Contributor specification for</p> <p>\"recognizing contributors to an open-source project in a way that rewards every contribution, not just code\", https://allcontributors.org/docs/en/overview</p> <p>There is a bot that helps a community use this specification in an automated way:</p> <p>\"The bot will automatically pull a user's profile, grab the contribution type emoji, update the project README and then open a Pull Request against the project \u2728\", https://allcontributors.org/docs/en/tooling</p> <p>This bot works well, but it only works at the level of a repository, not an organisation. When an organisation has multiple repositories, there is a need to capture all contributors (and their contribution types) at the level of the organisation.</p>"},{"location":"#goals-of-this-repo","title":"Goals of this repo","text":"<p>This repo will provide a way to fetch all of the <code>.all-contributorsrc</code> files from each repo contained with an organisation. Once fetched, it will combine them together and summarise each contributor and all of their unique contributions.</p> <p>See our Project Board for more incremental steps, and future enhancements.</p>"},{"location":"#oops-lets-not-duplicate-effort","title":"Oops, let's not duplicate effort","text":"<p>We don't want to duplicate effort, but we do want to be able to understand what we've made and maintain it! There are some previous discussions and efforts in this area (see this issue thread and this repository) and it would be good to combine efforts with people in the future, where possible.</p>"},{"location":"#usage","title":"Usage","text":""},{"location":"#inputs","title":"Inputs","text":"Input Name Input Description Required? <code>organisation</code> The name of the GitHub organisation to collect all-contributors from YES <code>target_repo</code> The name of the repository within the GitHub organisation where the merged all-contributors file will live YES <code>github_token</code> A GitHub token with permissions to write to the contents of the target repo and open pull requests. Defaults to: <code>GITHUB_TOKEN</code>. no <code>target_filepath</code> Path to a plain text file containing a list of repos within the organisation to exclude from the merge. Defaults to: <code>.repoignore</code>. no <code>base_branch</code> The name of the branch on the target repo to open pull requests against. Defaults to: <code>main</code>. no <code>head_branch</code> A prefix to prepend to head branches when opening pull requests. Defaults to: <code>merge-all-contributors</code>. no"},{"location":"#permissions","title":"Permissions","text":"<p>This Action will need permission to read the contents of a files stored in repositories in an organisation, create a new branch, commit to that branch, and open a Pull Request. The default permissive settings of <code>GITHUB_TOKEN</code> should provide the relevant permissions.</p> <p>If instead your repository is using the default restricted settings of <code>GITHUB_TOKEN</code>, you could grant just enough permissions to the Action using a <code>permissions</code> config, such as the one below:</p> <pre><code>permissions:\n  contents: write\n  pull-requests: write\n</code></pre>"},{"location":"#contributors","title":"Contributors \u2728","text":"<p>Thanks goes to these wonderful people (emoji key):</p> <sub>Jim Madge</sub>\ud83d\udcbb \ud83e\udd14 <sub>Niko Sirmpilatze</sub>\ud83e\udd14 \ud83d\udcbb <sub>Thomas Zwagerman</sub>\ud83e\udd14 \ud83d\udcbb <sub>Rachael Stickland</sub>\ud83e\udd14 \ud83d\udcbb <sub>Sarah Gibson</sub>\ud83e\udd14 \ud83d\udcbb <sub>Akram Karoune</sub>\ud83e\udd14 \ud83d\udcbb <sub>Sahil Raja</sub>\ud83e\udd14 \ud83d\udcbb <p>This project follows the all-contributors specification. Contributions of any kind welcome!</p>"},{"location":"#citation-license","title":"Citation &amp; License","text":"<p>fill</p>"},{"location":"diagrams/","title":"Technical Diagrams","text":"<p>Below is an technical overview of how <code>all-all-contributors</code> gather contributor information across an organisation's repositories.</p> <p> </p>"},{"location":"license/","title":"License","text":"<p>MIT License</p> <p>Copyright (c) 2025 The contributors</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"autoapi/summary/","title":"Summary","text":"<ul> <li>all_all_contributors<ul> <li>__about__</li> <li>cli</li> <li>github_api</li> <li>http_requests</li> <li>inject</li> <li>merge</li> <li>validate</li> <li>yaml_parser</li> </ul> </li> <li>tests<ul> <li>conftest</li> <li>test_cli</li> <li>test_github_api</li> <li>test_http_requests</li> <li>test_inject</li> <li>test_merge</li> <li>test_validate</li> </ul> </li> </ul>"},{"location":"autoapi/all_all_contributors/","title":"all_all_contributors","text":""},{"location":"autoapi/all_all_contributors/#all_all_contributors.cli","title":"<code>cli</code>","text":""},{"location":"autoapi/all_all_contributors/#all_all_contributors.cli.get_github_token","title":"<code>get_github_token()</code>","text":"<p>Read a GitHub token from the environment</p> Source code in <code>all_all_contributors/cli.py</code> <pre><code>def get_github_token() -&gt; str | None:\n    \"\"\"Read a GitHub token from the environment\"\"\"\n    token = getenv(\"INPUT_GITHUB_TOKEN\")\n    if token is None:\n        print(\"Environment variable INPUT_GITHUB_TOKEN is not defined\")\n        raise typer.Exit(code=1)\n    return token\n</code></pre>"},{"location":"autoapi/all_all_contributors/#all_all_contributors.cli.load_excluded_repos","title":"<code>load_excluded_repos()</code>","text":"<p>Load excluded repositories from a file</p> <p>Returns:</p> Name Type Description <code>set</code> <code>set</code> <p>A set of excluded repository names</p> Source code in <code>all_all_contributors/cli.py</code> <pre><code>def load_excluded_repos() -&gt; set:\n    \"\"\"Load excluded repositories from a file\n\n    Returns:\n        set: A set of excluded repository names\n    \"\"\"\n    ignore_file = getenv(\"INPUT_IGNORE_FILE\", \".repoignore\")\n    if path.exists(ignore_file):\n        with open(ignore_file) as f:\n            excluded = filter(lambda line: not line.startswith(\"#\"), f.readlines())\n    else:\n        print(f\"[skipping] No file found: {ignore_file}.\")\n        excluded = []\n\n    return set(excluded)\n</code></pre>"},{"location":"autoapi/all_all_contributors/#all_all_contributors.github_api","title":"<code>github_api</code>","text":""},{"location":"autoapi/all_all_contributors/#all_all_contributors.github_api.GitHubAPI","title":"<code>GitHubAPI</code>","text":"<p>Interact with the GitHub API and perform various git-flow tasks</p> Source code in <code>all_all_contributors/github_api.py</code> <pre><code>class GitHubAPI:\n    \"\"\"Interact with the GitHub API and perform various git-flow tasks\"\"\"\n\n    def __init__(\n        self,\n        org_name: str,\n        target_repo_name: str,\n        github_token: str,\n        target_filepath: str = \".all-contributorsrc\",\n        base_branch: str = \"main\",\n        head_branch: str = \"merge-all-contributors\",\n    ):\n        \"\"\"\n        Args:\n            org_name (str): The name of the GitHub organisation to target\n            target_repo_name (str): The name of the repo within `org_name` that\n                will host the combined .all-contributorsrc file\n            github_token (str): A GitHub token to authenticate API calls\n            target_filepath (str, optional): The filepath within `target_repo_name`\n                to the combined `.all-contributorsrc` file.\n                (default: \".all-contributorsrc\")\n            base_branch (str, optional): The name of the default branch in\n                `target_repo_name`. (default: \"main\")\n            head_branch (str, optional): A prefix for branches created in\n                `target_repo_name` for pull requests.\n                (default: \"all-all-contributors\")\n        \"\"\"\n        self.org_name = org_name\n        self.target_repo_name = target_repo_name\n        self.target_filepath = target_filepath\n        self.base_branch = base_branch\n        self.head_branch = head_branch\n\n        self.headers = {\n            \"Accept\": \"application/vnd.github.v3+json\",\n            \"Authorization\": f\"token {github_token}\",\n        }\n\n        self.api_url = \"https://api.github.com\"\n\n    def create_commit(\n        self,\n        contents: str,\n        commit_msg: str = \"Merging all contributors info from across the org\",\n    ):\n        \"\"\"Create a commit over the GitHub API by creating or updating a file\n\n        Args:\n            contents (str): The content of the file to be updated, encoded in base64\n            commit_msg (str): A message describing the changes the commit applies.\n                (default: \"Merging all contributors info from across the org\")\n        \"\"\"\n        print(\"Committing changes to file: {}\", self.target_filepath)\n        url = \"/\".join(\n            [\n                self.api_url,\n                \"repos\",\n                self.target_repo_name,\n                \"contents\",\n                self.target_filepath,\n            ]\n        )\n        body = {\n            \"message\": commit_msg,\n            \"content\": contents,\n            \"sha\": self.sha,\n            \"branch\": self.head_branch,\n        }\n        put(url, json=body, headers=self.headers)\n\n    def create_ref(self, ref: str, sha: str):\n        \"\"\"Create a new git reference (specifically, a branch) with GitHub's git\n        database API endpoint\n\n        Args:\n            ref (str): The reference or branch name to create\n            sha (str): The SHA of the parent commit to point the new reference to\n        \"\"\"\n        print(\"Creating new branch: {}\", ref)\n        url = \"/\".join([self.api_url, \"repos\", self.target_repo_name, \"git\", \"refs\"])\n        body = {\n            \"ref\": f\"refs/heads/{ref}\",\n            \"sha\": sha,\n        }\n        post_request(url, headers=self.headers, json=body)\n\n    def create_update_pull_request(self):\n        \"\"\"Create or update a Pull Request via the GitHub API\"\"\"\n        url = \"/\".join([self.api_url, \"repos\", self.target_repo_name, \"pulls\"])\n        pr = {\n            \"title\": \"Merging all-contributors across the org\",\n            \"body\": \"\",  # FIXME: Add a descriptove PR body here\n            \"base\": self.base_branch,\n        }\n\n        if self.pr_exists:\n            print(\"Updating Pull Request...\")\n\n            url = \"/\".join([url, str(self.pr_number)])\n            pr[\"state\"] = \"open\"\n            resp = patch_request(\n                url,\n                headers=self.headers,\n                json=pr,\n                return_json=True,\n            )\n\n            print(f\"Pull Request #{resp['number']} updated!\")\n        else:\n            print(\"Creating Pull Request...\")\n\n            pr[\"head\"] = self.head_branch\n            resp = post_request(\n                url,\n                headers=self.headers,\n                json=pr,\n                return_json=True,\n            )\n\n            print(f\"Pull Request #{resp['number']} created!\")\n\n    def find_existing_pull_request(self):\n        \"\"\"Check if the bot already has an open Pull Request\"\"\"\n        print(\"Finding Pull Requests previously opened to merge all contributors files\")\n\n        url = \"/\".join([self.api_url, \"repos\", self.target_repo_name, \"pulls\"])\n        params = {\"state\": \"open\", \"sort\": \"created\", \"direction\": \"desc\"}\n        resp = get_request(url, headers=self.headers, params=params, output=\"json\")\n\n        # Expression to match the head ref\n        matches = jmespath.search(\"[*].head.label\", resp)\n        indx, match = next(\n            (\n                (indx, match)\n                for (indx, match) in enumerate(matches)\n                if self.head_branch in match\n            ),\n            (None, None),\n        )\n\n        if (indx is None) and (match is None):\n            print(\"No relevant Pull Requests found. A new Pull Request will be opened.\")\n            random_id = \"\".join(random.sample(string.ascii_letters, 4))\n            self.head_branch = \"/\".join([self.head_branch, random_id])\n            self.pr_exists = False\n        else:\n            print(\n                \"Relevant Pull Request found. Will push new commits to this Pull Request.\"\n            )\n\n            self.head_branch = match.split(\":\")[-1]\n            self.pr_number = resp[indx][\"number\"]\n            self.pr_exists = True\n\n    def get_ref(self, ref: str) -&gt; dict:\n        \"\"\"Get a git reference (specifically, a HEAD ref) using GitHub's git\n        database API endpoint\n\n        Args:\n            ref (str): The reference for which to return information for\n\n        Returns:\n            dict: The JSON payload response of the request\n        \"\"\"\n        print(\"Pulling info for ref: {}\", ref)\n        url = \"/\".join(\n            [self.api_url, \"repos\", self.target_repo_name, \"git\", \"ref\", \"heads\", ref]\n        )\n        return get_request(url, headers=self.headers, output=\"json\")\n\n    def get_all_repos(self, excluded_repos: list) -&gt; list:\n        \"\"\"\n        Get all repositories from a GitHub organization using the GitHub API\n\n        Args:\n            excluded_repos (list): A list of excluded repos to skip\n\n        Returns:\n            list: A list of remaining repos in the organisation\n        \"\"\"\n        org_repos = []\n\n        # First API call\n        url = \"/\".join([self.api_url, \"orgs\", self.org_name, \"repos\"])\n        params = {\"type\": \"public\", \"per_page\": 100}\n        resp = get_request(url, headers=self.headers, params=params)\n        for repo in resp.json():\n            if repo[\"name\"] not in excluded_repos:\n                self.org_repos.append(repo[\"name\"])\n\n        # Paginate over results using the 'link' and rel['next'] parameters from\n        # the API response\n        # https://docs.github.com/en/rest/using-the-rest-api/using-pagination-in-the-rest-api\n        while \"link\" in resp.headers:\n            resp = get_request(\n                resp.links[\"next\"][\"url\"], headers=self.headers, params=params\n            )\n            for repo in resp.json:\n                if repo[\"name\"] not in excluded_repos:\n                    self.org_repos.append(repo[\"name\"])\n\n        return org_repos\n\n    def get_contributors_from_repo(\n        self, repo: str, filepath=\".all-contributorsrc\"\n    ) -&gt; list:\n        \"\"\"Get contributors from a specific repository using the GitHub API\n\n        Args:\n            repo (str): The name of the repository to extract contributors from\n            filepath (str): The filepath to extract contributors from (default: .all-contributorsrc)\n\n        Returns:\n            list: A list of contributors from the repository\n        \"\"\"\n        url = \"/\".join(\n            [self.api_url, \"repos\", self.org_name, repo, \"contents\", filepath]\n        )\n        resp = get_request(url, headers=self.headers, output=\"json\")\n        resp = get_request(resp[\"download_url\"], headers=self.headers, output=\"json\")\n        return resp[\"contributors\"]\n\n    def get_target_file_contents(self, ref):\n        \"\"\"Download the JSON-formatted contents of a target filepath in a target\n        repository inside a target GitHub org.\n\n        Args:\n            ref (str): The reference (branch) the file is stored on\n\n        Returns:\n            dict: The JSON formatted contents of the target filepath\n        \"\"\"\n        url = \"/\".join(\n            [\n                self.api_url,\n                \"repos\",\n                self.org_name,\n                self.target_repo_name,\n                \"contents\",\n                self.target_filepath,\n            ]\n        )\n        resp = get_request(\n            url, headers=self.headers, params={\"ref\": ref}, output=\"json\"\n        )\n        resp = get_ref(resp[\"download_url\"], headers=self.headers, output=\"json\")\n        return resp\n\n    def run(self) -&gt; None:\n        \"\"\"Run git flow to make a branch, commit a file, and open a PR\"\"\"\n        # Check if a PR exists\n        github_api.find_existing_pull_request()\n\n        # We want to work against the most up-to-date version of the target file\n        if github_api.pr_exists:\n            # If a PR exists, pull the file from there\n            file_contents = github_api.get_target_file_contents(github_api.head_branch)\n        else:\n            # Otherwise, pull from the base of the repo\n            file_contents = github_api.get_target_file_contents(github_api.base_branch)\n\n        file_contents = inject_config(file_contents, merged_contributors)\n\n        if not github_api.pr_exists:\n            # Create a branch to open a PR from\n            resp = github_api.get_ref(github_api.base_branch)\n            github_api.create_ref(github_api.head_brach, resp[\"object\"][\"sha\"])\n\n        # base64 encode the updated config file\n        encoded_file_contents = yaml.object_to_yaml_str(file_contents).encode(\"utf-8\")\n        base64_bytes = base64.b64encode(encoded_file_contents)\n        file_contents = base64_bytes.decode(\"utf-8\")\n\n        # Create a commit and open a pull request\n        github_api.create_commit(file_contents)\n        github_api.create_update_pull_request()\n</code></pre>"},{"location":"autoapi/all_all_contributors/#all_all_contributors.github_api.GitHubAPI.__init__","title":"<code>__init__(org_name, target_repo_name, github_token, target_filepath='.all-contributorsrc', base_branch='main', head_branch='merge-all-contributors')</code>","text":"<p>Parameters:</p> Name Type Description Default <code>org_name</code> <code>str</code> <p>The name of the GitHub organisation to target</p> required <code>target_repo_name</code> <code>str</code> <p>The name of the repo within <code>org_name</code> that will host the combined .all-contributorsrc file</p> required <code>github_token</code> <code>str</code> <p>A GitHub token to authenticate API calls</p> required <code>target_filepath</code> <code>str</code> <p>The filepath within <code>target_repo_name</code> to the combined <code>.all-contributorsrc</code> file. (default: \".all-contributorsrc\")</p> <code>'.all-contributorsrc'</code> <code>base_branch</code> <code>str</code> <p>The name of the default branch in <code>target_repo_name</code>. (default: \"main\")</p> <code>'main'</code> <code>head_branch</code> <code>str</code> <p>A prefix for branches created in <code>target_repo_name</code> for pull requests. (default: \"all-all-contributors\")</p> <code>'merge-all-contributors'</code> Source code in <code>all_all_contributors/github_api.py</code> <pre><code>def __init__(\n    self,\n    org_name: str,\n    target_repo_name: str,\n    github_token: str,\n    target_filepath: str = \".all-contributorsrc\",\n    base_branch: str = \"main\",\n    head_branch: str = \"merge-all-contributors\",\n):\n    \"\"\"\n    Args:\n        org_name (str): The name of the GitHub organisation to target\n        target_repo_name (str): The name of the repo within `org_name` that\n            will host the combined .all-contributorsrc file\n        github_token (str): A GitHub token to authenticate API calls\n        target_filepath (str, optional): The filepath within `target_repo_name`\n            to the combined `.all-contributorsrc` file.\n            (default: \".all-contributorsrc\")\n        base_branch (str, optional): The name of the default branch in\n            `target_repo_name`. (default: \"main\")\n        head_branch (str, optional): A prefix for branches created in\n            `target_repo_name` for pull requests.\n            (default: \"all-all-contributors\")\n    \"\"\"\n    self.org_name = org_name\n    self.target_repo_name = target_repo_name\n    self.target_filepath = target_filepath\n    self.base_branch = base_branch\n    self.head_branch = head_branch\n\n    self.headers = {\n        \"Accept\": \"application/vnd.github.v3+json\",\n        \"Authorization\": f\"token {github_token}\",\n    }\n\n    self.api_url = \"https://api.github.com\"\n</code></pre>"},{"location":"autoapi/all_all_contributors/#all_all_contributors.github_api.GitHubAPI.create_commit","title":"<code>create_commit(contents, commit_msg='Merging all contributors info from across the org')</code>","text":"<p>Create a commit over the GitHub API by creating or updating a file</p> <p>Parameters:</p> Name Type Description Default <code>contents</code> <code>str</code> <p>The content of the file to be updated, encoded in base64</p> required <code>commit_msg</code> <code>str</code> <p>A message describing the changes the commit applies. (default: \"Merging all contributors info from across the org\")</p> <code>'Merging all contributors info from across the org'</code> Source code in <code>all_all_contributors/github_api.py</code> <pre><code>def create_commit(\n    self,\n    contents: str,\n    commit_msg: str = \"Merging all contributors info from across the org\",\n):\n    \"\"\"Create a commit over the GitHub API by creating or updating a file\n\n    Args:\n        contents (str): The content of the file to be updated, encoded in base64\n        commit_msg (str): A message describing the changes the commit applies.\n            (default: \"Merging all contributors info from across the org\")\n    \"\"\"\n    print(\"Committing changes to file: {}\", self.target_filepath)\n    url = \"/\".join(\n        [\n            self.api_url,\n            \"repos\",\n            self.target_repo_name,\n            \"contents\",\n            self.target_filepath,\n        ]\n    )\n    body = {\n        \"message\": commit_msg,\n        \"content\": contents,\n        \"sha\": self.sha,\n        \"branch\": self.head_branch,\n    }\n    put(url, json=body, headers=self.headers)\n</code></pre>"},{"location":"autoapi/all_all_contributors/#all_all_contributors.github_api.GitHubAPI.create_ref","title":"<code>create_ref(ref, sha)</code>","text":"<p>Create a new git reference (specifically, a branch) with GitHub's git database API endpoint</p> <p>Parameters:</p> Name Type Description Default <code>ref</code> <code>str</code> <p>The reference or branch name to create</p> required <code>sha</code> <code>str</code> <p>The SHA of the parent commit to point the new reference to</p> required Source code in <code>all_all_contributors/github_api.py</code> <pre><code>def create_ref(self, ref: str, sha: str):\n    \"\"\"Create a new git reference (specifically, a branch) with GitHub's git\n    database API endpoint\n\n    Args:\n        ref (str): The reference or branch name to create\n        sha (str): The SHA of the parent commit to point the new reference to\n    \"\"\"\n    print(\"Creating new branch: {}\", ref)\n    url = \"/\".join([self.api_url, \"repos\", self.target_repo_name, \"git\", \"refs\"])\n    body = {\n        \"ref\": f\"refs/heads/{ref}\",\n        \"sha\": sha,\n    }\n    post_request(url, headers=self.headers, json=body)\n</code></pre>"},{"location":"autoapi/all_all_contributors/#all_all_contributors.github_api.GitHubAPI.create_update_pull_request","title":"<code>create_update_pull_request()</code>","text":"<p>Create or update a Pull Request via the GitHub API</p> Source code in <code>all_all_contributors/github_api.py</code> <pre><code>def create_update_pull_request(self):\n    \"\"\"Create or update a Pull Request via the GitHub API\"\"\"\n    url = \"/\".join([self.api_url, \"repos\", self.target_repo_name, \"pulls\"])\n    pr = {\n        \"title\": \"Merging all-contributors across the org\",\n        \"body\": \"\",  # FIXME: Add a descriptove PR body here\n        \"base\": self.base_branch,\n    }\n\n    if self.pr_exists:\n        print(\"Updating Pull Request...\")\n\n        url = \"/\".join([url, str(self.pr_number)])\n        pr[\"state\"] = \"open\"\n        resp = patch_request(\n            url,\n            headers=self.headers,\n            json=pr,\n            return_json=True,\n        )\n\n        print(f\"Pull Request #{resp['number']} updated!\")\n    else:\n        print(\"Creating Pull Request...\")\n\n        pr[\"head\"] = self.head_branch\n        resp = post_request(\n            url,\n            headers=self.headers,\n            json=pr,\n            return_json=True,\n        )\n\n        print(f\"Pull Request #{resp['number']} created!\")\n</code></pre>"},{"location":"autoapi/all_all_contributors/#all_all_contributors.github_api.GitHubAPI.find_existing_pull_request","title":"<code>find_existing_pull_request()</code>","text":"<p>Check if the bot already has an open Pull Request</p> Source code in <code>all_all_contributors/github_api.py</code> <pre><code>def find_existing_pull_request(self):\n    \"\"\"Check if the bot already has an open Pull Request\"\"\"\n    print(\"Finding Pull Requests previously opened to merge all contributors files\")\n\n    url = \"/\".join([self.api_url, \"repos\", self.target_repo_name, \"pulls\"])\n    params = {\"state\": \"open\", \"sort\": \"created\", \"direction\": \"desc\"}\n    resp = get_request(url, headers=self.headers, params=params, output=\"json\")\n\n    # Expression to match the head ref\n    matches = jmespath.search(\"[*].head.label\", resp)\n    indx, match = next(\n        (\n            (indx, match)\n            for (indx, match) in enumerate(matches)\n            if self.head_branch in match\n        ),\n        (None, None),\n    )\n\n    if (indx is None) and (match is None):\n        print(\"No relevant Pull Requests found. A new Pull Request will be opened.\")\n        random_id = \"\".join(random.sample(string.ascii_letters, 4))\n        self.head_branch = \"/\".join([self.head_branch, random_id])\n        self.pr_exists = False\n    else:\n        print(\n            \"Relevant Pull Request found. Will push new commits to this Pull Request.\"\n        )\n\n        self.head_branch = match.split(\":\")[-1]\n        self.pr_number = resp[indx][\"number\"]\n        self.pr_exists = True\n</code></pre>"},{"location":"autoapi/all_all_contributors/#all_all_contributors.github_api.GitHubAPI.get_all_repos","title":"<code>get_all_repos(excluded_repos)</code>","text":"<p>Get all repositories from a GitHub organization using the GitHub API</p> <p>Parameters:</p> Name Type Description Default <code>excluded_repos</code> <code>list</code> <p>A list of excluded repos to skip</p> required <p>Returns:</p> Name Type Description <code>list</code> <code>list</code> <p>A list of remaining repos in the organisation</p> Source code in <code>all_all_contributors/github_api.py</code> <pre><code>def get_all_repos(self, excluded_repos: list) -&gt; list:\n    \"\"\"\n    Get all repositories from a GitHub organization using the GitHub API\n\n    Args:\n        excluded_repos (list): A list of excluded repos to skip\n\n    Returns:\n        list: A list of remaining repos in the organisation\n    \"\"\"\n    org_repos = []\n\n    # First API call\n    url = \"/\".join([self.api_url, \"orgs\", self.org_name, \"repos\"])\n    params = {\"type\": \"public\", \"per_page\": 100}\n    resp = get_request(url, headers=self.headers, params=params)\n    for repo in resp.json():\n        if repo[\"name\"] not in excluded_repos:\n            self.org_repos.append(repo[\"name\"])\n\n    # Paginate over results using the 'link' and rel['next'] parameters from\n    # the API response\n    # https://docs.github.com/en/rest/using-the-rest-api/using-pagination-in-the-rest-api\n    while \"link\" in resp.headers:\n        resp = get_request(\n            resp.links[\"next\"][\"url\"], headers=self.headers, params=params\n        )\n        for repo in resp.json:\n            if repo[\"name\"] not in excluded_repos:\n                self.org_repos.append(repo[\"name\"])\n\n    return org_repos\n</code></pre>"},{"location":"autoapi/all_all_contributors/#all_all_contributors.github_api.GitHubAPI.get_contributors_from_repo","title":"<code>get_contributors_from_repo(repo, filepath='.all-contributorsrc')</code>","text":"<p>Get contributors from a specific repository using the GitHub API</p> <p>Parameters:</p> Name Type Description Default <code>repo</code> <code>str</code> <p>The name of the repository to extract contributors from</p> required <code>filepath</code> <code>str</code> <p>The filepath to extract contributors from (default: .all-contributorsrc)</p> <code>'.all-contributorsrc'</code> <p>Returns:</p> Name Type Description <code>list</code> <code>list</code> <p>A list of contributors from the repository</p> Source code in <code>all_all_contributors/github_api.py</code> <pre><code>def get_contributors_from_repo(\n    self, repo: str, filepath=\".all-contributorsrc\"\n) -&gt; list:\n    \"\"\"Get contributors from a specific repository using the GitHub API\n\n    Args:\n        repo (str): The name of the repository to extract contributors from\n        filepath (str): The filepath to extract contributors from (default: .all-contributorsrc)\n\n    Returns:\n        list: A list of contributors from the repository\n    \"\"\"\n    url = \"/\".join(\n        [self.api_url, \"repos\", self.org_name, repo, \"contents\", filepath]\n    )\n    resp = get_request(url, headers=self.headers, output=\"json\")\n    resp = get_request(resp[\"download_url\"], headers=self.headers, output=\"json\")\n    return resp[\"contributors\"]\n</code></pre>"},{"location":"autoapi/all_all_contributors/#all_all_contributors.github_api.GitHubAPI.get_ref","title":"<code>get_ref(ref)</code>","text":"<p>Get a git reference (specifically, a HEAD ref) using GitHub's git database API endpoint</p> <p>Parameters:</p> Name Type Description Default <code>ref</code> <code>str</code> <p>The reference for which to return information for</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>The JSON payload response of the request</p> Source code in <code>all_all_contributors/github_api.py</code> <pre><code>def get_ref(self, ref: str) -&gt; dict:\n    \"\"\"Get a git reference (specifically, a HEAD ref) using GitHub's git\n    database API endpoint\n\n    Args:\n        ref (str): The reference for which to return information for\n\n    Returns:\n        dict: The JSON payload response of the request\n    \"\"\"\n    print(\"Pulling info for ref: {}\", ref)\n    url = \"/\".join(\n        [self.api_url, \"repos\", self.target_repo_name, \"git\", \"ref\", \"heads\", ref]\n    )\n    return get_request(url, headers=self.headers, output=\"json\")\n</code></pre>"},{"location":"autoapi/all_all_contributors/#all_all_contributors.github_api.GitHubAPI.get_target_file_contents","title":"<code>get_target_file_contents(ref)</code>","text":"<p>Download the JSON-formatted contents of a target filepath in a target repository inside a target GitHub org.</p> <p>Parameters:</p> Name Type Description Default <code>ref</code> <code>str</code> <p>The reference (branch) the file is stored on</p> required <p>Returns:</p> Name Type Description <code>dict</code> <p>The JSON formatted contents of the target filepath</p> Source code in <code>all_all_contributors/github_api.py</code> <pre><code>def get_target_file_contents(self, ref):\n    \"\"\"Download the JSON-formatted contents of a target filepath in a target\n    repository inside a target GitHub org.\n\n    Args:\n        ref (str): The reference (branch) the file is stored on\n\n    Returns:\n        dict: The JSON formatted contents of the target filepath\n    \"\"\"\n    url = \"/\".join(\n        [\n            self.api_url,\n            \"repos\",\n            self.org_name,\n            self.target_repo_name,\n            \"contents\",\n            self.target_filepath,\n        ]\n    )\n    resp = get_request(\n        url, headers=self.headers, params={\"ref\": ref}, output=\"json\"\n    )\n    resp = get_ref(resp[\"download_url\"], headers=self.headers, output=\"json\")\n    return resp\n</code></pre>"},{"location":"autoapi/all_all_contributors/#all_all_contributors.github_api.GitHubAPI.run","title":"<code>run()</code>","text":"<p>Run git flow to make a branch, commit a file, and open a PR</p> Source code in <code>all_all_contributors/github_api.py</code> <pre><code>def run(self) -&gt; None:\n    \"\"\"Run git flow to make a branch, commit a file, and open a PR\"\"\"\n    # Check if a PR exists\n    github_api.find_existing_pull_request()\n\n    # We want to work against the most up-to-date version of the target file\n    if github_api.pr_exists:\n        # If a PR exists, pull the file from there\n        file_contents = github_api.get_target_file_contents(github_api.head_branch)\n    else:\n        # Otherwise, pull from the base of the repo\n        file_contents = github_api.get_target_file_contents(github_api.base_branch)\n\n    file_contents = inject_config(file_contents, merged_contributors)\n\n    if not github_api.pr_exists:\n        # Create a branch to open a PR from\n        resp = github_api.get_ref(github_api.base_branch)\n        github_api.create_ref(github_api.head_brach, resp[\"object\"][\"sha\"])\n\n    # base64 encode the updated config file\n    encoded_file_contents = yaml.object_to_yaml_str(file_contents).encode(\"utf-8\")\n    base64_bytes = base64.b64encode(encoded_file_contents)\n    file_contents = base64_bytes.decode(\"utf-8\")\n\n    # Create a commit and open a pull request\n    github_api.create_commit(file_contents)\n    github_api.create_update_pull_request()\n</code></pre>"},{"location":"autoapi/all_all_contributors/#all_all_contributors.http_requests","title":"<code>http_requests</code>","text":"<p>A set of basic functional wrappers around HTTP verbs</p> <ul> <li>get: customise response format</li> <li>patch</li> <li>post</li> </ul>"},{"location":"autoapi/all_all_contributors/#all_all_contributors.http_requests.get_request","title":"<code>get_request(url, headers={}, params={}, output='default')</code>","text":"<p>Send a GET request to an HTTP API endpoint</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The URL to send the request to</p> required <code>headers</code> <code>dict</code> <p>A dictionary of headers to send with the request. Defaults to an empty dict.</p> <code>{}</code> <code>params</code> <code>dict</code> <p>A dictionary of parameters to send with the request. Defaults to an empty dict.</p> <code>{}</code> <code>output</code> <code>str</code> <p>The format in which to output the response in. Currently accepts 'default', 'json' or 'text'. 'default' does not apply any format parsing of the response.</p> <code>'default'</code> <p>Returns:</p> Name Type Description <code>resp</code> <p>A formatted response from the HTTP request</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>An unexpected output format was chosen.</p> Source code in <code>all_all_contributors/http_requests.py</code> <pre><code>def get_request(url, headers={}, params={}, output=\"default\"):\n    \"\"\"Send a GET request to an HTTP API endpoint\n\n    Args:\n        url (str): The URL to send the request to\n        headers (dict, optional): A dictionary of headers to send with the\n            request. Defaults to an empty dict.\n        params (dict, optional): A dictionary of parameters to send with the\n            request. Defaults to an empty dict.\n        output (str): The format in which to output the response in. Currently\n            accepts 'default', 'json' or 'text'. 'default' does not apply any\n            format parsing of the response.\n\n    Returns:\n        resp: A formatted response from the HTTP request\n\n    Raises:\n        ValueError: An unexpected output format was chosen.\n    \"\"\"\n    accepted_formats = [\"default\", \"json\", \"text\"]\n    if output not in accepted_formats:\n        raise ValueError(\n            \"Invalid output format. Please choose one of the following options: %s\"\n            % accepted_formats\n        )\n\n    resp = requests.get(url, headers=headers, params=params)\n\n    if not resp:\n        raise requests.HTTPError(f\"{resp.text}\\nRequest URL: {url}\")\n\n    if output == \"default\":\n        return resp\n    elif output == \"json\":\n        return resp.json()\n    elif output == \"text\":\n        return resp.text\n</code></pre>"},{"location":"autoapi/all_all_contributors/#all_all_contributors.http_requests.patch_request","title":"<code>patch_request(url, headers={}, json={}, return_json=False)</code>","text":"<p>Send a PATCH request to an HTTP API endpoint</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The URL to send the request to</p> required <code>headers</code> <code>dict</code> <p>A dictionary of any headers to send with the request. Defaults to an empty dictionary.</p> <code>{}</code> <code>json</code> <code>dict</code> <p>A dictionary containing JSON payload to send with the request. Defaults to an empty dictionary.</p> <code>{}</code> <code>return_json</code> <code>bool</code> <p>Return the JSON payload response. Defaults to False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>resp</code> <p>A JSON formatted response from a HTTP response</p> <p>Raises:</p> Type Description <code>HTTPError</code> <p>An error was returned by the HTTP request</p> Source code in <code>all_all_contributors/http_requests.py</code> <pre><code>def patch_request(url, headers={}, json={}, return_json=False):\n    \"\"\"Send a PATCH request to an HTTP API endpoint\n\n    Args:\n        url (str): The URL to send the request to\n        headers (dict, optional): A dictionary of any headers to send with the\n            request. Defaults to an empty dictionary.\n        json (dict, optional): A dictionary containing JSON payload to send with\n            the request. Defaults to an empty dictionary.\n        return_json (bool, optional): Return the JSON payload response.\n            Defaults to False.\n\n    Returns:\n        resp: A JSON formatted response from a HTTP response\n\n    Raises:\n        HTTPError: An error was returned by the HTTP request\n    \"\"\"\n    resp = requests.patch(url, headers=headers, json=json)\n\n    if not resp:\n        raise requests.HTTPError(f\"{resp.text}\\nRequest URL: {url}\")\n\n    if return_json:\n        return resp.json()\n</code></pre>"},{"location":"autoapi/all_all_contributors/#all_all_contributors.http_requests.post_request","title":"<code>post_request(url, headers={}, json={}, return_json=False)</code>","text":"<p>Send a POST request to an HTTP API endpoint</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The URL to send the request to</p> required <code>headers</code> <code>dict</code> <p>A dictionary of any headers to send with the request. Defaults to an empty dictionary.</p> <code>{}</code> <code>json</code> <code>dict</code> <p>A dictionary containing JSON payload to send with the request. Defaults to an empty dictionary.</p> <code>{}</code> <code>return_json</code> <code>bool</code> <p>Return the JSON payload response. Defaults to False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>resp</code> <p>A JSON formatted response from a HTTP request</p> <p>Raises:</p> Type Description <code>HTTPError</code> <p>An error was returned by the HTTP request</p> Source code in <code>all_all_contributors/http_requests.py</code> <pre><code>def post_request(url, headers={}, json={}, return_json=False):\n    \"\"\"Send a POST request to an HTTP API endpoint\n\n    Args:\n        url (str): The URL to send the request to\n        headers (dict, optional): A dictionary of any headers to send with the\n            request. Defaults to an empty dictionary.\n        json (dict, optional): A dictionary containing JSON payload to send with\n            the request. Defaults to an empty dictionary.\n        return_json (bool, optional): Return the JSON payload response.\n            Defaults to False.\n\n    Returns:\n        resp: A JSON formatted response from a HTTP request\n\n    Raises:\n        HTTPError: An error was returned by the HTTP request\n    \"\"\"\n    resp = requests.post(url, headers=headers, json=json)\n\n    if not resp:\n        raise requests.HTTPError(f\"{resp.text}\\nRequest URL: {url}\")\n\n    if return_json:\n        return resp.json()\n</code></pre>"},{"location":"autoapi/all_all_contributors/#all_all_contributors.inject","title":"<code>inject</code>","text":""},{"location":"autoapi/all_all_contributors/#all_all_contributors.inject.inject_config","title":"<code>inject_config(all_contributors_rc, contributors)</code>","text":"<p>Replace the 'contributors' field of an all contributors configuration JSON dict with a new list</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict[Any]</code> <p>Updated .all-contributorsrc config in JSON dict format</p> Source code in <code>all_all_contributors/inject.py</code> <pre><code>def inject_config(all_contributors_rc: dict[Any], contributors: list[Any]) -&gt; dict[Any]:\n    \"\"\"Replace the 'contributors' field of an all contributors configuration\n    JSON dict with a new list\n\n    Returns:\n        dict: Updated .all-contributorsrc config in JSON dict format\n    \"\"\"\n    if \"contributors\" in all_contributors_rc.keys():\n        all_contributors_rc[\"contributors\"] = contributors\n    else:\n        raise AttributeError(\"All contributors file is missing 'contributors' field\")\n\n    validate_all_contributors_rc(all_contributors_rc)\n    return all_contributors_rc\n</code></pre>"},{"location":"autoapi/all_all_contributors/#all_all_contributors.merge","title":"<code>merge</code>","text":"<p>Merge contributors from multiple .all-contributorsrc files into a single list.</p>"},{"location":"autoapi/all_all_contributors/#all_all_contributors.merge.merge_contributions","title":"<code>merge_contributions(first, second)</code>","text":"<p>Return a sorted list of the contribution types for two contributor entries</p> Source code in <code>all_all_contributors/merge.py</code> <pre><code>def merge_contributions(first: Contributor, second: Contributor) -&gt; Contributor:\n    \"\"\"Return a sorted list of the contribution types for two contributor entries\"\"\"\n    return sorted(\n        or_set(\n            first.get(_contributions),\n            second.get(_contributions),\n        )\n    )\n</code></pre>"},{"location":"autoapi/all_all_contributors/#all_all_contributors.merge.merge_contributors","title":"<code>merge_contributors(contributors_list)</code>","text":"<p>Merge multiple lists of contributor dictionaries into a single list.</p> <p>This function takes a list of contributor dictionaries (typically from different .all-contributorsrc files) and merges them based on unique profile URLs. When multiple entries exist for the same contributor, their contributions are aggregated into a single entry.</p> <p>Parameters:</p> Name Type Description Default <code>contributors_list</code> <code>list[Contributor]</code> <p>A list of contributor dictionaries. Each contributor dict should have at least 'profile' and 'contributions' keys.</p> required <p>Returns:</p> Type Description <code>list[Contributor]</code> <p>list[dict[str, Any]]: A list of merged contributor dictionaries, where each contributor appears only once with their combined contributions.</p> Note <p>The function merges contributors based on merge._unique_key and aggregates contributions types.</p> Source code in <code>all_all_contributors/merge.py</code> <pre><code>def merge_contributors(contributors_list: list[Contributor]) -&gt; list[Contributor]:\n    \"\"\"Merge multiple lists of contributor dictionaries into a single list.\n\n    This function takes a list of contributor dictionaries (typically from\n    different .all-contributorsrc files) and merges them based on unique\n    profile URLs. When multiple entries exist for the same contributor, their\n    contributions are aggregated into a single entry.\n\n    Args:\n        contributors_list: A list of contributor dictionaries. Each contributor\n            dict should have at least 'profile' and 'contributions' keys.\n\n    Returns:\n        list[dict[str, Any]]: A list of merged contributor dictionaries, where\n            each contributor appears only once with their combined contributions.\n\n    Note:\n        The function merges contributors based on merge._unique_key and\n        aggregates contributions types.\n    \"\"\"\n\n    all_contributors = {}\n\n    for contributor in contributors_list:\n        if (key := contributor.get(_unique_key)) in all_contributors.keys():\n            all_contributors[key][_contributions] = merge_contributions(\n                all_contributors[key], contributor\n            )\n        else:\n            all_contributors[key] = contributor.copy()\n\n    return list(all_contributors.values())\n</code></pre>"},{"location":"autoapi/all_all_contributors/#all_all_contributors.merge.or_set","title":"<code>or_set(first, second)</code>","text":"<p>Return list of values that appear in <code>first</code> or <code>second</code></p> Source code in <code>all_all_contributors/merge.py</code> <pre><code>def or_set(first: list[Any], second: list[Any]) -&gt; list[Any]:\n    \"\"\"Return list of values that appear in `first` or `second`\"\"\"\n    return list(set(first + second))\n</code></pre>"},{"location":"autoapi/all_all_contributors/#all_all_contributors.validate","title":"<code>validate</code>","text":""},{"location":"autoapi/all_all_contributors/#all_all_contributors.validate.validate_all_contributors_rc","title":"<code>validate_all_contributors_rc(all_contributors_rc)</code>","text":"<p>Validate an all contributors configuration object against the schema</p> <p>Raises:</p> Type Description <code>ValidationError</code> <p>if the configuration is not valid</p> <code>SchemaError</code> <p>if the schema is not valid</p> Source code in <code>all_all_contributors/validate.py</code> <pre><code>def validate_all_contributors_rc(all_contributors_rc: dict[Any]) -&gt; None:\n    \"\"\"\n    Validate an all contributors configuration object against the schema\n\n    Raises:\n        ValidationError: if the configuration is not valid\n        SchemaError: if the schema is not valid\n    \"\"\"\n    schema = requests.get(\"https://json.schemastore.org/all-contributors.json\").json()\n    jsonschema.validate(all_contributors_rc, schema)\n</code></pre>"},{"location":"autoapi/all_all_contributors/#all_all_contributors.yaml_parser","title":"<code>yaml_parser</code>","text":"<p>Class to safely parse yaml to string and vice versa</p>"},{"location":"autoapi/all_all_contributors/__about__/","title":"__about__","text":""},{"location":"autoapi/all_all_contributors/cli/","title":"cli","text":""},{"location":"autoapi/all_all_contributors/cli/#all_all_contributors.cli.get_github_token","title":"<code>get_github_token()</code>","text":"<p>Read a GitHub token from the environment</p> Source code in <code>all_all_contributors/cli.py</code> <pre><code>def get_github_token() -&gt; str | None:\n    \"\"\"Read a GitHub token from the environment\"\"\"\n    token = getenv(\"INPUT_GITHUB_TOKEN\")\n    if token is None:\n        print(\"Environment variable INPUT_GITHUB_TOKEN is not defined\")\n        raise typer.Exit(code=1)\n    return token\n</code></pre>"},{"location":"autoapi/all_all_contributors/cli/#all_all_contributors.cli.load_excluded_repos","title":"<code>load_excluded_repos()</code>","text":"<p>Load excluded repositories from a file</p> <p>Returns:</p> Name Type Description <code>set</code> <code>set</code> <p>A set of excluded repository names</p> Source code in <code>all_all_contributors/cli.py</code> <pre><code>def load_excluded_repos() -&gt; set:\n    \"\"\"Load excluded repositories from a file\n\n    Returns:\n        set: A set of excluded repository names\n    \"\"\"\n    ignore_file = getenv(\"INPUT_IGNORE_FILE\", \".repoignore\")\n    if path.exists(ignore_file):\n        with open(ignore_file) as f:\n            excluded = filter(lambda line: not line.startswith(\"#\"), f.readlines())\n    else:\n        print(f\"[skipping] No file found: {ignore_file}.\")\n        excluded = []\n\n    return set(excluded)\n</code></pre>"},{"location":"autoapi/all_all_contributors/github_api/","title":"github_api","text":""},{"location":"autoapi/all_all_contributors/github_api/#all_all_contributors.github_api.GitHubAPI","title":"<code>GitHubAPI</code>","text":"<p>Interact with the GitHub API and perform various git-flow tasks</p> Source code in <code>all_all_contributors/github_api.py</code> <pre><code>class GitHubAPI:\n    \"\"\"Interact with the GitHub API and perform various git-flow tasks\"\"\"\n\n    def __init__(\n        self,\n        org_name: str,\n        target_repo_name: str,\n        github_token: str,\n        target_filepath: str = \".all-contributorsrc\",\n        base_branch: str = \"main\",\n        head_branch: str = \"merge-all-contributors\",\n    ):\n        \"\"\"\n        Args:\n            org_name (str): The name of the GitHub organisation to target\n            target_repo_name (str): The name of the repo within `org_name` that\n                will host the combined .all-contributorsrc file\n            github_token (str): A GitHub token to authenticate API calls\n            target_filepath (str, optional): The filepath within `target_repo_name`\n                to the combined `.all-contributorsrc` file.\n                (default: \".all-contributorsrc\")\n            base_branch (str, optional): The name of the default branch in\n                `target_repo_name`. (default: \"main\")\n            head_branch (str, optional): A prefix for branches created in\n                `target_repo_name` for pull requests.\n                (default: \"all-all-contributors\")\n        \"\"\"\n        self.org_name = org_name\n        self.target_repo_name = target_repo_name\n        self.target_filepath = target_filepath\n        self.base_branch = base_branch\n        self.head_branch = head_branch\n\n        self.headers = {\n            \"Accept\": \"application/vnd.github.v3+json\",\n            \"Authorization\": f\"token {github_token}\",\n        }\n\n        self.api_url = \"https://api.github.com\"\n\n    def create_commit(\n        self,\n        contents: str,\n        commit_msg: str = \"Merging all contributors info from across the org\",\n    ):\n        \"\"\"Create a commit over the GitHub API by creating or updating a file\n\n        Args:\n            contents (str): The content of the file to be updated, encoded in base64\n            commit_msg (str): A message describing the changes the commit applies.\n                (default: \"Merging all contributors info from across the org\")\n        \"\"\"\n        print(\"Committing changes to file: {}\", self.target_filepath)\n        url = \"/\".join(\n            [\n                self.api_url,\n                \"repos\",\n                self.target_repo_name,\n                \"contents\",\n                self.target_filepath,\n            ]\n        )\n        body = {\n            \"message\": commit_msg,\n            \"content\": contents,\n            \"sha\": self.sha,\n            \"branch\": self.head_branch,\n        }\n        put(url, json=body, headers=self.headers)\n\n    def create_ref(self, ref: str, sha: str):\n        \"\"\"Create a new git reference (specifically, a branch) with GitHub's git\n        database API endpoint\n\n        Args:\n            ref (str): The reference or branch name to create\n            sha (str): The SHA of the parent commit to point the new reference to\n        \"\"\"\n        print(\"Creating new branch: {}\", ref)\n        url = \"/\".join([self.api_url, \"repos\", self.target_repo_name, \"git\", \"refs\"])\n        body = {\n            \"ref\": f\"refs/heads/{ref}\",\n            \"sha\": sha,\n        }\n        post_request(url, headers=self.headers, json=body)\n\n    def create_update_pull_request(self):\n        \"\"\"Create or update a Pull Request via the GitHub API\"\"\"\n        url = \"/\".join([self.api_url, \"repos\", self.target_repo_name, \"pulls\"])\n        pr = {\n            \"title\": \"Merging all-contributors across the org\",\n            \"body\": \"\",  # FIXME: Add a descriptove PR body here\n            \"base\": self.base_branch,\n        }\n\n        if self.pr_exists:\n            print(\"Updating Pull Request...\")\n\n            url = \"/\".join([url, str(self.pr_number)])\n            pr[\"state\"] = \"open\"\n            resp = patch_request(\n                url,\n                headers=self.headers,\n                json=pr,\n                return_json=True,\n            )\n\n            print(f\"Pull Request #{resp['number']} updated!\")\n        else:\n            print(\"Creating Pull Request...\")\n\n            pr[\"head\"] = self.head_branch\n            resp = post_request(\n                url,\n                headers=self.headers,\n                json=pr,\n                return_json=True,\n            )\n\n            print(f\"Pull Request #{resp['number']} created!\")\n\n    def find_existing_pull_request(self):\n        \"\"\"Check if the bot already has an open Pull Request\"\"\"\n        print(\"Finding Pull Requests previously opened to merge all contributors files\")\n\n        url = \"/\".join([self.api_url, \"repos\", self.target_repo_name, \"pulls\"])\n        params = {\"state\": \"open\", \"sort\": \"created\", \"direction\": \"desc\"}\n        resp = get_request(url, headers=self.headers, params=params, output=\"json\")\n\n        # Expression to match the head ref\n        matches = jmespath.search(\"[*].head.label\", resp)\n        indx, match = next(\n            (\n                (indx, match)\n                for (indx, match) in enumerate(matches)\n                if self.head_branch in match\n            ),\n            (None, None),\n        )\n\n        if (indx is None) and (match is None):\n            print(\"No relevant Pull Requests found. A new Pull Request will be opened.\")\n            random_id = \"\".join(random.sample(string.ascii_letters, 4))\n            self.head_branch = \"/\".join([self.head_branch, random_id])\n            self.pr_exists = False\n        else:\n            print(\n                \"Relevant Pull Request found. Will push new commits to this Pull Request.\"\n            )\n\n            self.head_branch = match.split(\":\")[-1]\n            self.pr_number = resp[indx][\"number\"]\n            self.pr_exists = True\n\n    def get_ref(self, ref: str) -&gt; dict:\n        \"\"\"Get a git reference (specifically, a HEAD ref) using GitHub's git\n        database API endpoint\n\n        Args:\n            ref (str): The reference for which to return information for\n\n        Returns:\n            dict: The JSON payload response of the request\n        \"\"\"\n        print(\"Pulling info for ref: {}\", ref)\n        url = \"/\".join(\n            [self.api_url, \"repos\", self.target_repo_name, \"git\", \"ref\", \"heads\", ref]\n        )\n        return get_request(url, headers=self.headers, output=\"json\")\n\n    def get_all_repos(self, excluded_repos: list) -&gt; list:\n        \"\"\"\n        Get all repositories from a GitHub organization using the GitHub API\n\n        Args:\n            excluded_repos (list): A list of excluded repos to skip\n\n        Returns:\n            list: A list of remaining repos in the organisation\n        \"\"\"\n        org_repos = []\n\n        # First API call\n        url = \"/\".join([self.api_url, \"orgs\", self.org_name, \"repos\"])\n        params = {\"type\": \"public\", \"per_page\": 100}\n        resp = get_request(url, headers=self.headers, params=params)\n        for repo in resp.json():\n            if repo[\"name\"] not in excluded_repos:\n                self.org_repos.append(repo[\"name\"])\n\n        # Paginate over results using the 'link' and rel['next'] parameters from\n        # the API response\n        # https://docs.github.com/en/rest/using-the-rest-api/using-pagination-in-the-rest-api\n        while \"link\" in resp.headers:\n            resp = get_request(\n                resp.links[\"next\"][\"url\"], headers=self.headers, params=params\n            )\n            for repo in resp.json:\n                if repo[\"name\"] not in excluded_repos:\n                    self.org_repos.append(repo[\"name\"])\n\n        return org_repos\n\n    def get_contributors_from_repo(\n        self, repo: str, filepath=\".all-contributorsrc\"\n    ) -&gt; list:\n        \"\"\"Get contributors from a specific repository using the GitHub API\n\n        Args:\n            repo (str): The name of the repository to extract contributors from\n            filepath (str): The filepath to extract contributors from (default: .all-contributorsrc)\n\n        Returns:\n            list: A list of contributors from the repository\n        \"\"\"\n        url = \"/\".join(\n            [self.api_url, \"repos\", self.org_name, repo, \"contents\", filepath]\n        )\n        resp = get_request(url, headers=self.headers, output=\"json\")\n        resp = get_request(resp[\"download_url\"], headers=self.headers, output=\"json\")\n        return resp[\"contributors\"]\n\n    def get_target_file_contents(self, ref):\n        \"\"\"Download the JSON-formatted contents of a target filepath in a target\n        repository inside a target GitHub org.\n\n        Args:\n            ref (str): The reference (branch) the file is stored on\n\n        Returns:\n            dict: The JSON formatted contents of the target filepath\n        \"\"\"\n        url = \"/\".join(\n            [\n                self.api_url,\n                \"repos\",\n                self.org_name,\n                self.target_repo_name,\n                \"contents\",\n                self.target_filepath,\n            ]\n        )\n        resp = get_request(\n            url, headers=self.headers, params={\"ref\": ref}, output=\"json\"\n        )\n        resp = get_ref(resp[\"download_url\"], headers=self.headers, output=\"json\")\n        return resp\n\n    def run(self) -&gt; None:\n        \"\"\"Run git flow to make a branch, commit a file, and open a PR\"\"\"\n        # Check if a PR exists\n        github_api.find_existing_pull_request()\n\n        # We want to work against the most up-to-date version of the target file\n        if github_api.pr_exists:\n            # If a PR exists, pull the file from there\n            file_contents = github_api.get_target_file_contents(github_api.head_branch)\n        else:\n            # Otherwise, pull from the base of the repo\n            file_contents = github_api.get_target_file_contents(github_api.base_branch)\n\n        file_contents = inject_config(file_contents, merged_contributors)\n\n        if not github_api.pr_exists:\n            # Create a branch to open a PR from\n            resp = github_api.get_ref(github_api.base_branch)\n            github_api.create_ref(github_api.head_brach, resp[\"object\"][\"sha\"])\n\n        # base64 encode the updated config file\n        encoded_file_contents = yaml.object_to_yaml_str(file_contents).encode(\"utf-8\")\n        base64_bytes = base64.b64encode(encoded_file_contents)\n        file_contents = base64_bytes.decode(\"utf-8\")\n\n        # Create a commit and open a pull request\n        github_api.create_commit(file_contents)\n        github_api.create_update_pull_request()\n</code></pre>"},{"location":"autoapi/all_all_contributors/github_api/#all_all_contributors.github_api.GitHubAPI.__init__","title":"<code>__init__(org_name, target_repo_name, github_token, target_filepath='.all-contributorsrc', base_branch='main', head_branch='merge-all-contributors')</code>","text":"<p>Parameters:</p> Name Type Description Default <code>org_name</code> <code>str</code> <p>The name of the GitHub organisation to target</p> required <code>target_repo_name</code> <code>str</code> <p>The name of the repo within <code>org_name</code> that will host the combined .all-contributorsrc file</p> required <code>github_token</code> <code>str</code> <p>A GitHub token to authenticate API calls</p> required <code>target_filepath</code> <code>str</code> <p>The filepath within <code>target_repo_name</code> to the combined <code>.all-contributorsrc</code> file. (default: \".all-contributorsrc\")</p> <code>'.all-contributorsrc'</code> <code>base_branch</code> <code>str</code> <p>The name of the default branch in <code>target_repo_name</code>. (default: \"main\")</p> <code>'main'</code> <code>head_branch</code> <code>str</code> <p>A prefix for branches created in <code>target_repo_name</code> for pull requests. (default: \"all-all-contributors\")</p> <code>'merge-all-contributors'</code> Source code in <code>all_all_contributors/github_api.py</code> <pre><code>def __init__(\n    self,\n    org_name: str,\n    target_repo_name: str,\n    github_token: str,\n    target_filepath: str = \".all-contributorsrc\",\n    base_branch: str = \"main\",\n    head_branch: str = \"merge-all-contributors\",\n):\n    \"\"\"\n    Args:\n        org_name (str): The name of the GitHub organisation to target\n        target_repo_name (str): The name of the repo within `org_name` that\n            will host the combined .all-contributorsrc file\n        github_token (str): A GitHub token to authenticate API calls\n        target_filepath (str, optional): The filepath within `target_repo_name`\n            to the combined `.all-contributorsrc` file.\n            (default: \".all-contributorsrc\")\n        base_branch (str, optional): The name of the default branch in\n            `target_repo_name`. (default: \"main\")\n        head_branch (str, optional): A prefix for branches created in\n            `target_repo_name` for pull requests.\n            (default: \"all-all-contributors\")\n    \"\"\"\n    self.org_name = org_name\n    self.target_repo_name = target_repo_name\n    self.target_filepath = target_filepath\n    self.base_branch = base_branch\n    self.head_branch = head_branch\n\n    self.headers = {\n        \"Accept\": \"application/vnd.github.v3+json\",\n        \"Authorization\": f\"token {github_token}\",\n    }\n\n    self.api_url = \"https://api.github.com\"\n</code></pre>"},{"location":"autoapi/all_all_contributors/github_api/#all_all_contributors.github_api.GitHubAPI.create_commit","title":"<code>create_commit(contents, commit_msg='Merging all contributors info from across the org')</code>","text":"<p>Create a commit over the GitHub API by creating or updating a file</p> <p>Parameters:</p> Name Type Description Default <code>contents</code> <code>str</code> <p>The content of the file to be updated, encoded in base64</p> required <code>commit_msg</code> <code>str</code> <p>A message describing the changes the commit applies. (default: \"Merging all contributors info from across the org\")</p> <code>'Merging all contributors info from across the org'</code> Source code in <code>all_all_contributors/github_api.py</code> <pre><code>def create_commit(\n    self,\n    contents: str,\n    commit_msg: str = \"Merging all contributors info from across the org\",\n):\n    \"\"\"Create a commit over the GitHub API by creating or updating a file\n\n    Args:\n        contents (str): The content of the file to be updated, encoded in base64\n        commit_msg (str): A message describing the changes the commit applies.\n            (default: \"Merging all contributors info from across the org\")\n    \"\"\"\n    print(\"Committing changes to file: {}\", self.target_filepath)\n    url = \"/\".join(\n        [\n            self.api_url,\n            \"repos\",\n            self.target_repo_name,\n            \"contents\",\n            self.target_filepath,\n        ]\n    )\n    body = {\n        \"message\": commit_msg,\n        \"content\": contents,\n        \"sha\": self.sha,\n        \"branch\": self.head_branch,\n    }\n    put(url, json=body, headers=self.headers)\n</code></pre>"},{"location":"autoapi/all_all_contributors/github_api/#all_all_contributors.github_api.GitHubAPI.create_ref","title":"<code>create_ref(ref, sha)</code>","text":"<p>Create a new git reference (specifically, a branch) with GitHub's git database API endpoint</p> <p>Parameters:</p> Name Type Description Default <code>ref</code> <code>str</code> <p>The reference or branch name to create</p> required <code>sha</code> <code>str</code> <p>The SHA of the parent commit to point the new reference to</p> required Source code in <code>all_all_contributors/github_api.py</code> <pre><code>def create_ref(self, ref: str, sha: str):\n    \"\"\"Create a new git reference (specifically, a branch) with GitHub's git\n    database API endpoint\n\n    Args:\n        ref (str): The reference or branch name to create\n        sha (str): The SHA of the parent commit to point the new reference to\n    \"\"\"\n    print(\"Creating new branch: {}\", ref)\n    url = \"/\".join([self.api_url, \"repos\", self.target_repo_name, \"git\", \"refs\"])\n    body = {\n        \"ref\": f\"refs/heads/{ref}\",\n        \"sha\": sha,\n    }\n    post_request(url, headers=self.headers, json=body)\n</code></pre>"},{"location":"autoapi/all_all_contributors/github_api/#all_all_contributors.github_api.GitHubAPI.create_update_pull_request","title":"<code>create_update_pull_request()</code>","text":"<p>Create or update a Pull Request via the GitHub API</p> Source code in <code>all_all_contributors/github_api.py</code> <pre><code>def create_update_pull_request(self):\n    \"\"\"Create or update a Pull Request via the GitHub API\"\"\"\n    url = \"/\".join([self.api_url, \"repos\", self.target_repo_name, \"pulls\"])\n    pr = {\n        \"title\": \"Merging all-contributors across the org\",\n        \"body\": \"\",  # FIXME: Add a descriptove PR body here\n        \"base\": self.base_branch,\n    }\n\n    if self.pr_exists:\n        print(\"Updating Pull Request...\")\n\n        url = \"/\".join([url, str(self.pr_number)])\n        pr[\"state\"] = \"open\"\n        resp = patch_request(\n            url,\n            headers=self.headers,\n            json=pr,\n            return_json=True,\n        )\n\n        print(f\"Pull Request #{resp['number']} updated!\")\n    else:\n        print(\"Creating Pull Request...\")\n\n        pr[\"head\"] = self.head_branch\n        resp = post_request(\n            url,\n            headers=self.headers,\n            json=pr,\n            return_json=True,\n        )\n\n        print(f\"Pull Request #{resp['number']} created!\")\n</code></pre>"},{"location":"autoapi/all_all_contributors/github_api/#all_all_contributors.github_api.GitHubAPI.find_existing_pull_request","title":"<code>find_existing_pull_request()</code>","text":"<p>Check if the bot already has an open Pull Request</p> Source code in <code>all_all_contributors/github_api.py</code> <pre><code>def find_existing_pull_request(self):\n    \"\"\"Check if the bot already has an open Pull Request\"\"\"\n    print(\"Finding Pull Requests previously opened to merge all contributors files\")\n\n    url = \"/\".join([self.api_url, \"repos\", self.target_repo_name, \"pulls\"])\n    params = {\"state\": \"open\", \"sort\": \"created\", \"direction\": \"desc\"}\n    resp = get_request(url, headers=self.headers, params=params, output=\"json\")\n\n    # Expression to match the head ref\n    matches = jmespath.search(\"[*].head.label\", resp)\n    indx, match = next(\n        (\n            (indx, match)\n            for (indx, match) in enumerate(matches)\n            if self.head_branch in match\n        ),\n        (None, None),\n    )\n\n    if (indx is None) and (match is None):\n        print(\"No relevant Pull Requests found. A new Pull Request will be opened.\")\n        random_id = \"\".join(random.sample(string.ascii_letters, 4))\n        self.head_branch = \"/\".join([self.head_branch, random_id])\n        self.pr_exists = False\n    else:\n        print(\n            \"Relevant Pull Request found. Will push new commits to this Pull Request.\"\n        )\n\n        self.head_branch = match.split(\":\")[-1]\n        self.pr_number = resp[indx][\"number\"]\n        self.pr_exists = True\n</code></pre>"},{"location":"autoapi/all_all_contributors/github_api/#all_all_contributors.github_api.GitHubAPI.get_all_repos","title":"<code>get_all_repos(excluded_repos)</code>","text":"<p>Get all repositories from a GitHub organization using the GitHub API</p> <p>Parameters:</p> Name Type Description Default <code>excluded_repos</code> <code>list</code> <p>A list of excluded repos to skip</p> required <p>Returns:</p> Name Type Description <code>list</code> <code>list</code> <p>A list of remaining repos in the organisation</p> Source code in <code>all_all_contributors/github_api.py</code> <pre><code>def get_all_repos(self, excluded_repos: list) -&gt; list:\n    \"\"\"\n    Get all repositories from a GitHub organization using the GitHub API\n\n    Args:\n        excluded_repos (list): A list of excluded repos to skip\n\n    Returns:\n        list: A list of remaining repos in the organisation\n    \"\"\"\n    org_repos = []\n\n    # First API call\n    url = \"/\".join([self.api_url, \"orgs\", self.org_name, \"repos\"])\n    params = {\"type\": \"public\", \"per_page\": 100}\n    resp = get_request(url, headers=self.headers, params=params)\n    for repo in resp.json():\n        if repo[\"name\"] not in excluded_repos:\n            self.org_repos.append(repo[\"name\"])\n\n    # Paginate over results using the 'link' and rel['next'] parameters from\n    # the API response\n    # https://docs.github.com/en/rest/using-the-rest-api/using-pagination-in-the-rest-api\n    while \"link\" in resp.headers:\n        resp = get_request(\n            resp.links[\"next\"][\"url\"], headers=self.headers, params=params\n        )\n        for repo in resp.json:\n            if repo[\"name\"] not in excluded_repos:\n                self.org_repos.append(repo[\"name\"])\n\n    return org_repos\n</code></pre>"},{"location":"autoapi/all_all_contributors/github_api/#all_all_contributors.github_api.GitHubAPI.get_contributors_from_repo","title":"<code>get_contributors_from_repo(repo, filepath='.all-contributorsrc')</code>","text":"<p>Get contributors from a specific repository using the GitHub API</p> <p>Parameters:</p> Name Type Description Default <code>repo</code> <code>str</code> <p>The name of the repository to extract contributors from</p> required <code>filepath</code> <code>str</code> <p>The filepath to extract contributors from (default: .all-contributorsrc)</p> <code>'.all-contributorsrc'</code> <p>Returns:</p> Name Type Description <code>list</code> <code>list</code> <p>A list of contributors from the repository</p> Source code in <code>all_all_contributors/github_api.py</code> <pre><code>def get_contributors_from_repo(\n    self, repo: str, filepath=\".all-contributorsrc\"\n) -&gt; list:\n    \"\"\"Get contributors from a specific repository using the GitHub API\n\n    Args:\n        repo (str): The name of the repository to extract contributors from\n        filepath (str): The filepath to extract contributors from (default: .all-contributorsrc)\n\n    Returns:\n        list: A list of contributors from the repository\n    \"\"\"\n    url = \"/\".join(\n        [self.api_url, \"repos\", self.org_name, repo, \"contents\", filepath]\n    )\n    resp = get_request(url, headers=self.headers, output=\"json\")\n    resp = get_request(resp[\"download_url\"], headers=self.headers, output=\"json\")\n    return resp[\"contributors\"]\n</code></pre>"},{"location":"autoapi/all_all_contributors/github_api/#all_all_contributors.github_api.GitHubAPI.get_ref","title":"<code>get_ref(ref)</code>","text":"<p>Get a git reference (specifically, a HEAD ref) using GitHub's git database API endpoint</p> <p>Parameters:</p> Name Type Description Default <code>ref</code> <code>str</code> <p>The reference for which to return information for</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>The JSON payload response of the request</p> Source code in <code>all_all_contributors/github_api.py</code> <pre><code>def get_ref(self, ref: str) -&gt; dict:\n    \"\"\"Get a git reference (specifically, a HEAD ref) using GitHub's git\n    database API endpoint\n\n    Args:\n        ref (str): The reference for which to return information for\n\n    Returns:\n        dict: The JSON payload response of the request\n    \"\"\"\n    print(\"Pulling info for ref: {}\", ref)\n    url = \"/\".join(\n        [self.api_url, \"repos\", self.target_repo_name, \"git\", \"ref\", \"heads\", ref]\n    )\n    return get_request(url, headers=self.headers, output=\"json\")\n</code></pre>"},{"location":"autoapi/all_all_contributors/github_api/#all_all_contributors.github_api.GitHubAPI.get_target_file_contents","title":"<code>get_target_file_contents(ref)</code>","text":"<p>Download the JSON-formatted contents of a target filepath in a target repository inside a target GitHub org.</p> <p>Parameters:</p> Name Type Description Default <code>ref</code> <code>str</code> <p>The reference (branch) the file is stored on</p> required <p>Returns:</p> Name Type Description <code>dict</code> <p>The JSON formatted contents of the target filepath</p> Source code in <code>all_all_contributors/github_api.py</code> <pre><code>def get_target_file_contents(self, ref):\n    \"\"\"Download the JSON-formatted contents of a target filepath in a target\n    repository inside a target GitHub org.\n\n    Args:\n        ref (str): The reference (branch) the file is stored on\n\n    Returns:\n        dict: The JSON formatted contents of the target filepath\n    \"\"\"\n    url = \"/\".join(\n        [\n            self.api_url,\n            \"repos\",\n            self.org_name,\n            self.target_repo_name,\n            \"contents\",\n            self.target_filepath,\n        ]\n    )\n    resp = get_request(\n        url, headers=self.headers, params={\"ref\": ref}, output=\"json\"\n    )\n    resp = get_ref(resp[\"download_url\"], headers=self.headers, output=\"json\")\n    return resp\n</code></pre>"},{"location":"autoapi/all_all_contributors/github_api/#all_all_contributors.github_api.GitHubAPI.run","title":"<code>run()</code>","text":"<p>Run git flow to make a branch, commit a file, and open a PR</p> Source code in <code>all_all_contributors/github_api.py</code> <pre><code>def run(self) -&gt; None:\n    \"\"\"Run git flow to make a branch, commit a file, and open a PR\"\"\"\n    # Check if a PR exists\n    github_api.find_existing_pull_request()\n\n    # We want to work against the most up-to-date version of the target file\n    if github_api.pr_exists:\n        # If a PR exists, pull the file from there\n        file_contents = github_api.get_target_file_contents(github_api.head_branch)\n    else:\n        # Otherwise, pull from the base of the repo\n        file_contents = github_api.get_target_file_contents(github_api.base_branch)\n\n    file_contents = inject_config(file_contents, merged_contributors)\n\n    if not github_api.pr_exists:\n        # Create a branch to open a PR from\n        resp = github_api.get_ref(github_api.base_branch)\n        github_api.create_ref(github_api.head_brach, resp[\"object\"][\"sha\"])\n\n    # base64 encode the updated config file\n    encoded_file_contents = yaml.object_to_yaml_str(file_contents).encode(\"utf-8\")\n    base64_bytes = base64.b64encode(encoded_file_contents)\n    file_contents = base64_bytes.decode(\"utf-8\")\n\n    # Create a commit and open a pull request\n    github_api.create_commit(file_contents)\n    github_api.create_update_pull_request()\n</code></pre>"},{"location":"autoapi/all_all_contributors/http_requests/","title":"http_requests","text":"<p>A set of basic functional wrappers around HTTP verbs</p> <ul> <li>get: customise response format</li> <li>patch</li> <li>post</li> </ul>"},{"location":"autoapi/all_all_contributors/http_requests/#all_all_contributors.http_requests.get_request","title":"<code>get_request(url, headers={}, params={}, output='default')</code>","text":"<p>Send a GET request to an HTTP API endpoint</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The URL to send the request to</p> required <code>headers</code> <code>dict</code> <p>A dictionary of headers to send with the request. Defaults to an empty dict.</p> <code>{}</code> <code>params</code> <code>dict</code> <p>A dictionary of parameters to send with the request. Defaults to an empty dict.</p> <code>{}</code> <code>output</code> <code>str</code> <p>The format in which to output the response in. Currently accepts 'default', 'json' or 'text'. 'default' does not apply any format parsing of the response.</p> <code>'default'</code> <p>Returns:</p> Name Type Description <code>resp</code> <p>A formatted response from the HTTP request</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>An unexpected output format was chosen.</p> Source code in <code>all_all_contributors/http_requests.py</code> <pre><code>def get_request(url, headers={}, params={}, output=\"default\"):\n    \"\"\"Send a GET request to an HTTP API endpoint\n\n    Args:\n        url (str): The URL to send the request to\n        headers (dict, optional): A dictionary of headers to send with the\n            request. Defaults to an empty dict.\n        params (dict, optional): A dictionary of parameters to send with the\n            request. Defaults to an empty dict.\n        output (str): The format in which to output the response in. Currently\n            accepts 'default', 'json' or 'text'. 'default' does not apply any\n            format parsing of the response.\n\n    Returns:\n        resp: A formatted response from the HTTP request\n\n    Raises:\n        ValueError: An unexpected output format was chosen.\n    \"\"\"\n    accepted_formats = [\"default\", \"json\", \"text\"]\n    if output not in accepted_formats:\n        raise ValueError(\n            \"Invalid output format. Please choose one of the following options: %s\"\n            % accepted_formats\n        )\n\n    resp = requests.get(url, headers=headers, params=params)\n\n    if not resp:\n        raise requests.HTTPError(f\"{resp.text}\\nRequest URL: {url}\")\n\n    if output == \"default\":\n        return resp\n    elif output == \"json\":\n        return resp.json()\n    elif output == \"text\":\n        return resp.text\n</code></pre>"},{"location":"autoapi/all_all_contributors/http_requests/#all_all_contributors.http_requests.patch_request","title":"<code>patch_request(url, headers={}, json={}, return_json=False)</code>","text":"<p>Send a PATCH request to an HTTP API endpoint</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The URL to send the request to</p> required <code>headers</code> <code>dict</code> <p>A dictionary of any headers to send with the request. Defaults to an empty dictionary.</p> <code>{}</code> <code>json</code> <code>dict</code> <p>A dictionary containing JSON payload to send with the request. Defaults to an empty dictionary.</p> <code>{}</code> <code>return_json</code> <code>bool</code> <p>Return the JSON payload response. Defaults to False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>resp</code> <p>A JSON formatted response from a HTTP response</p> <p>Raises:</p> Type Description <code>HTTPError</code> <p>An error was returned by the HTTP request</p> Source code in <code>all_all_contributors/http_requests.py</code> <pre><code>def patch_request(url, headers={}, json={}, return_json=False):\n    \"\"\"Send a PATCH request to an HTTP API endpoint\n\n    Args:\n        url (str): The URL to send the request to\n        headers (dict, optional): A dictionary of any headers to send with the\n            request. Defaults to an empty dictionary.\n        json (dict, optional): A dictionary containing JSON payload to send with\n            the request. Defaults to an empty dictionary.\n        return_json (bool, optional): Return the JSON payload response.\n            Defaults to False.\n\n    Returns:\n        resp: A JSON formatted response from a HTTP response\n\n    Raises:\n        HTTPError: An error was returned by the HTTP request\n    \"\"\"\n    resp = requests.patch(url, headers=headers, json=json)\n\n    if not resp:\n        raise requests.HTTPError(f\"{resp.text}\\nRequest URL: {url}\")\n\n    if return_json:\n        return resp.json()\n</code></pre>"},{"location":"autoapi/all_all_contributors/http_requests/#all_all_contributors.http_requests.post_request","title":"<code>post_request(url, headers={}, json={}, return_json=False)</code>","text":"<p>Send a POST request to an HTTP API endpoint</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The URL to send the request to</p> required <code>headers</code> <code>dict</code> <p>A dictionary of any headers to send with the request. Defaults to an empty dictionary.</p> <code>{}</code> <code>json</code> <code>dict</code> <p>A dictionary containing JSON payload to send with the request. Defaults to an empty dictionary.</p> <code>{}</code> <code>return_json</code> <code>bool</code> <p>Return the JSON payload response. Defaults to False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>resp</code> <p>A JSON formatted response from a HTTP request</p> <p>Raises:</p> Type Description <code>HTTPError</code> <p>An error was returned by the HTTP request</p> Source code in <code>all_all_contributors/http_requests.py</code> <pre><code>def post_request(url, headers={}, json={}, return_json=False):\n    \"\"\"Send a POST request to an HTTP API endpoint\n\n    Args:\n        url (str): The URL to send the request to\n        headers (dict, optional): A dictionary of any headers to send with the\n            request. Defaults to an empty dictionary.\n        json (dict, optional): A dictionary containing JSON payload to send with\n            the request. Defaults to an empty dictionary.\n        return_json (bool, optional): Return the JSON payload response.\n            Defaults to False.\n\n    Returns:\n        resp: A JSON formatted response from a HTTP request\n\n    Raises:\n        HTTPError: An error was returned by the HTTP request\n    \"\"\"\n    resp = requests.post(url, headers=headers, json=json)\n\n    if not resp:\n        raise requests.HTTPError(f\"{resp.text}\\nRequest URL: {url}\")\n\n    if return_json:\n        return resp.json()\n</code></pre>"},{"location":"autoapi/all_all_contributors/inject/","title":"inject","text":""},{"location":"autoapi/all_all_contributors/inject/#all_all_contributors.inject.inject_config","title":"<code>inject_config(all_contributors_rc, contributors)</code>","text":"<p>Replace the 'contributors' field of an all contributors configuration JSON dict with a new list</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict[Any]</code> <p>Updated .all-contributorsrc config in JSON dict format</p> Source code in <code>all_all_contributors/inject.py</code> <pre><code>def inject_config(all_contributors_rc: dict[Any], contributors: list[Any]) -&gt; dict[Any]:\n    \"\"\"Replace the 'contributors' field of an all contributors configuration\n    JSON dict with a new list\n\n    Returns:\n        dict: Updated .all-contributorsrc config in JSON dict format\n    \"\"\"\n    if \"contributors\" in all_contributors_rc.keys():\n        all_contributors_rc[\"contributors\"] = contributors\n    else:\n        raise AttributeError(\"All contributors file is missing 'contributors' field\")\n\n    validate_all_contributors_rc(all_contributors_rc)\n    return all_contributors_rc\n</code></pre>"},{"location":"autoapi/all_all_contributors/merge/","title":"merge","text":"<p>Merge contributors from multiple .all-contributorsrc files into a single list.</p>"},{"location":"autoapi/all_all_contributors/merge/#all_all_contributors.merge.merge_contributions","title":"<code>merge_contributions(first, second)</code>","text":"<p>Return a sorted list of the contribution types for two contributor entries</p> Source code in <code>all_all_contributors/merge.py</code> <pre><code>def merge_contributions(first: Contributor, second: Contributor) -&gt; Contributor:\n    \"\"\"Return a sorted list of the contribution types for two contributor entries\"\"\"\n    return sorted(\n        or_set(\n            first.get(_contributions),\n            second.get(_contributions),\n        )\n    )\n</code></pre>"},{"location":"autoapi/all_all_contributors/merge/#all_all_contributors.merge.merge_contributors","title":"<code>merge_contributors(contributors_list)</code>","text":"<p>Merge multiple lists of contributor dictionaries into a single list.</p> <p>This function takes a list of contributor dictionaries (typically from different .all-contributorsrc files) and merges them based on unique profile URLs. When multiple entries exist for the same contributor, their contributions are aggregated into a single entry.</p> <p>Parameters:</p> Name Type Description Default <code>contributors_list</code> <code>list[Contributor]</code> <p>A list of contributor dictionaries. Each contributor dict should have at least 'profile' and 'contributions' keys.</p> required <p>Returns:</p> Type Description <code>list[Contributor]</code> <p>list[dict[str, Any]]: A list of merged contributor dictionaries, where each contributor appears only once with their combined contributions.</p> Note <p>The function merges contributors based on merge._unique_key and aggregates contributions types.</p> Source code in <code>all_all_contributors/merge.py</code> <pre><code>def merge_contributors(contributors_list: list[Contributor]) -&gt; list[Contributor]:\n    \"\"\"Merge multiple lists of contributor dictionaries into a single list.\n\n    This function takes a list of contributor dictionaries (typically from\n    different .all-contributorsrc files) and merges them based on unique\n    profile URLs. When multiple entries exist for the same contributor, their\n    contributions are aggregated into a single entry.\n\n    Args:\n        contributors_list: A list of contributor dictionaries. Each contributor\n            dict should have at least 'profile' and 'contributions' keys.\n\n    Returns:\n        list[dict[str, Any]]: A list of merged contributor dictionaries, where\n            each contributor appears only once with their combined contributions.\n\n    Note:\n        The function merges contributors based on merge._unique_key and\n        aggregates contributions types.\n    \"\"\"\n\n    all_contributors = {}\n\n    for contributor in contributors_list:\n        if (key := contributor.get(_unique_key)) in all_contributors.keys():\n            all_contributors[key][_contributions] = merge_contributions(\n                all_contributors[key], contributor\n            )\n        else:\n            all_contributors[key] = contributor.copy()\n\n    return list(all_contributors.values())\n</code></pre>"},{"location":"autoapi/all_all_contributors/merge/#all_all_contributors.merge.or_set","title":"<code>or_set(first, second)</code>","text":"<p>Return list of values that appear in <code>first</code> or <code>second</code></p> Source code in <code>all_all_contributors/merge.py</code> <pre><code>def or_set(first: list[Any], second: list[Any]) -&gt; list[Any]:\n    \"\"\"Return list of values that appear in `first` or `second`\"\"\"\n    return list(set(first + second))\n</code></pre>"},{"location":"autoapi/all_all_contributors/validate/","title":"validate","text":""},{"location":"autoapi/all_all_contributors/validate/#all_all_contributors.validate.validate_all_contributors_rc","title":"<code>validate_all_contributors_rc(all_contributors_rc)</code>","text":"<p>Validate an all contributors configuration object against the schema</p> <p>Raises:</p> Type Description <code>ValidationError</code> <p>if the configuration is not valid</p> <code>SchemaError</code> <p>if the schema is not valid</p> Source code in <code>all_all_contributors/validate.py</code> <pre><code>def validate_all_contributors_rc(all_contributors_rc: dict[Any]) -&gt; None:\n    \"\"\"\n    Validate an all contributors configuration object against the schema\n\n    Raises:\n        ValidationError: if the configuration is not valid\n        SchemaError: if the schema is not valid\n    \"\"\"\n    schema = requests.get(\"https://json.schemastore.org/all-contributors.json\").json()\n    jsonschema.validate(all_contributors_rc, schema)\n</code></pre>"},{"location":"autoapi/all_all_contributors/yaml_parser/","title":"yaml_parser","text":"<p>Class to safely parse yaml to string and vice versa</p>"},{"location":"autoapi/tests/conftest/","title":"conftest","text":""},{"location":"autoapi/tests/test_cli/","title":"test_cli","text":""},{"location":"autoapi/tests/test_github_api/","title":"test_github_api","text":""},{"location":"autoapi/tests/test_http_requests/","title":"test_http_requests","text":""},{"location":"autoapi/tests/test_inject/","title":"test_inject","text":""},{"location":"autoapi/tests/test_merge/","title":"test_merge","text":"<p>Test the merge_contributors function.</p>"},{"location":"autoapi/tests/test_merge/#tests.test_merge.TestMergeContributors","title":"<code>TestMergeContributors</code>","text":"Source code in <code>tests/test_merge.py</code> <pre><code>class TestMergeContributors:\n    def test_merge_contributors(self, contributor_1, contributor_2):\n        \"\"\"Test that the merge_contributors function merges contributors correctly.\"\"\"\n        contributors_list = [contributor_1, contributor_2]\n        # Merge a list with duplicates\n        merged_contributors = merge_contributors(contributors_list + contributors_list)\n        # the merged list should just have 2 contributors\n        assert len(merged_contributors) == 2\n        # the merged list should have the same contributors as the original lists\n        assert contributor_in(contributor_1, merged_contributors)\n        assert contributor_in(contributor_2, merged_contributors)\n\n    def test_merge_contributors_duplicate(\n        self,\n        contributor_1,\n        contributor_1_duplicate,\n        contributor_1_merged,\n        contributor_2,\n    ):\n        \"\"\"Test that the merge_contributors function merges contributors correctly.\"\"\"\n        contributors_list = [contributor_1, contributor_1_duplicate, contributor_2]\n        # Merge a list with duplicates\n        merged_contributors = merge_contributors(contributors_list)\n        # the merged list should just have 2 contributors\n        assert len(merged_contributors) == 2\n        # the merged list should have contributor 2, but a merged entry for contributor 1\n        assert not contributor_in(contributor_1, merged_contributors)\n        assert not contributor_in(contributor_1_duplicate, merged_contributors)\n        assert contributor_in(contributor_1_merged, merged_contributors)\n        assert contributor_in(contributor_2, merged_contributors)\n</code></pre>"},{"location":"autoapi/tests/test_merge/#tests.test_merge.TestMergeContributors.test_merge_contributors","title":"<code>test_merge_contributors(contributor_1, contributor_2)</code>","text":"<p>Test that the merge_contributors function merges contributors correctly.</p> Source code in <code>tests/test_merge.py</code> <pre><code>def test_merge_contributors(self, contributor_1, contributor_2):\n    \"\"\"Test that the merge_contributors function merges contributors correctly.\"\"\"\n    contributors_list = [contributor_1, contributor_2]\n    # Merge a list with duplicates\n    merged_contributors = merge_contributors(contributors_list + contributors_list)\n    # the merged list should just have 2 contributors\n    assert len(merged_contributors) == 2\n    # the merged list should have the same contributors as the original lists\n    assert contributor_in(contributor_1, merged_contributors)\n    assert contributor_in(contributor_2, merged_contributors)\n</code></pre>"},{"location":"autoapi/tests/test_merge/#tests.test_merge.TestMergeContributors.test_merge_contributors_duplicate","title":"<code>test_merge_contributors_duplicate(contributor_1, contributor_1_duplicate, contributor_1_merged, contributor_2)</code>","text":"<p>Test that the merge_contributors function merges contributors correctly.</p> Source code in <code>tests/test_merge.py</code> <pre><code>def test_merge_contributors_duplicate(\n    self,\n    contributor_1,\n    contributor_1_duplicate,\n    contributor_1_merged,\n    contributor_2,\n):\n    \"\"\"Test that the merge_contributors function merges contributors correctly.\"\"\"\n    contributors_list = [contributor_1, contributor_1_duplicate, contributor_2]\n    # Merge a list with duplicates\n    merged_contributors = merge_contributors(contributors_list)\n    # the merged list should just have 2 contributors\n    assert len(merged_contributors) == 2\n    # the merged list should have contributor 2, but a merged entry for contributor 1\n    assert not contributor_in(contributor_1, merged_contributors)\n    assert not contributor_in(contributor_1_duplicate, merged_contributors)\n    assert contributor_in(contributor_1_merged, merged_contributors)\n    assert contributor_in(contributor_2, merged_contributors)\n</code></pre>"},{"location":"autoapi/tests/test_merge/#tests.test_merge.contributor_in","title":"<code>contributor_in(contributor, contributor_list)</code>","text":"<p>Check if a contributor appears in a list</p> Source code in <code>tests/test_merge.py</code> <pre><code>def contributor_in(contributor, contributor_list):\n    \"\"\"Check if a contributor appears in a list\"\"\"\n    key = contributor.get(_unique_key)\n    contributions = contributor.get(_contributions)\n\n    for contributor_b in contributor_list:\n        # Match contributor by unique key\n        if contributor_b.get(_unique_key) == key:\n            contributions_b = contributor_b.get(_contributions)\n            if (\n                # Ensure length of contributions lists are identical\n                len(contributions) == len(contributions_b)\n                # and that all contributions feature in each list\n                and all(\n                    [contribution in contributions_b for contribution in contributions]\n                )\n            ):\n                return True\n            else:\n                return False\n\n    # Return false if no matching contributor is found\n    return False\n</code></pre>"},{"location":"autoapi/tests/test_validate/","title":"test_validate","text":""},{"location":"developer/documentation/","title":"Documentation Guide","text":"<p>The documentation is built using mkdocs. We use mkdocstrings and mkdocs-autoapi to automatically generate the API references.</p>"},{"location":"developer/documentation/#building-the-docs","title":"Building the Docs","text":"<p>To preview the documentation locally: <pre><code>hatch run docs:serve\n</code></pre></p> <p>To build the documentation: <pre><code>hatch run docs:build\n</code></pre></p>"},{"location":"developer/documentation/#navigation","title":"Navigation","text":"<p>The navigation is handled in <code>mkdocs.yml</code>: <pre><code>nav:\n  - Overview: index.md\n  - Developer Guide:\n    - Documentation: developer/documentation.md\n  - License: license.md\n</code></pre> The pages listed here can be edited manually.</p> <p>Note that the API section (which is not listed under <code>nav:</code>) is automatically generated using <code>mkdocstrings</code> and <code>mkdocs-autoapi</code>, when you call <code>mkdocs serve</code>.</p> <p>This is because we use the following configuration in <code>mkdocs.yml</code>: <pre><code>plugins:\n  - search\n  - mkdocs-autoapi:\n      autoapi_add_nav_entry: API\n  - mkdocstrings:\n      handlers:\n        python:\n          paths:\n            - .\n          options:\n            show_submodules: true\n            docstring_style: google\n            heading_level: 3\n</code></pre></p> <p>Therefore, there is no need to create or edit <code>.md</code> files when you make a change to the code under <code>all_all_contributors/</code>. Do make sure you update the docstrings if needed.</p>"},{"location":"developer/documentation/#docstrings-style","title":"Docstrings Style","text":"<p>For the docstrings, please follow the [Google Style Guide][https://google.github.io/styleguide/pyguide.html#383-functions-and-methods]. For more information on <code>mkdocstrings</code>, see their [Docstring Options][https://mkdocstrings.github.io/python/usage/configuration/docstrings/].</p>"}]}